---
import Menu from './Menu.astro'
import '@styles/header.sass'
import '@styles/editor.sass'
import '@styles/notes.sass'
---

<header class="editor-header">
	<button class="export">save as file</button>
	<Menu />
</header>
<main></main>
<script>
	import { Editor, rootCtx } from '@milkdown/kit/core'
	import { clipboard } from '@milkdown/kit/plugin/clipboard'
	import { history } from '@milkdown/kit/plugin/history'
	import { indent } from '@milkdown/kit/plugin/indent'
	import { listener, listenerCtx } from '@milkdown/kit/plugin/listener'
	import { upload } from '@milkdown/kit/plugin/upload'
	import { commonmark } from '@milkdown/kit/preset/commonmark'
	import { buildEditor } from '@utils/buildEditor'
	import { debug } from '@utils/debug'
	import { del } from '@utils/del'
	import { exportFile } from '@utils/exportFile'
	import { getNotes } from '@utils/getNotes'
	import { save } from '@utils/save'
	import { nanoid } from 'nanoid/non-secure'

	// Utilities
	const autosaveInterval = 5_000
	// Other
	const opfs = await (
		await navigator.storage.getDirectory()
	).getDirectoryHandle('md', { create: true })
	const rootEl: HTMLElement = document.getElementsByTagName('main')[0]
	const notes = await getNotes(opfs)

	// Assinged selectors
	let editorEl: HTMLDivElement = null
	let notesEl: HTMLUListElement = null
	// States
	let updated = false
	let empty = true
	let hasNotes = notes?.length > 0

	const editor = await Editor.make()
		.use(commonmark)
		.use(history)
		.use(clipboard)
		.use(upload)
		.use(indent)
		.use(listener)
		.config((ctx) => {
			ctx.set(rootCtx, rootEl)
			const listener = ctx.get(listenerCtx)

			listener.mounted(() => {
				editorEl = (
					document.getElementsByClassName(
						'editor',
					) as HTMLCollectionOf<HTMLDivElement>
				)[0]
				if (hasNotes) editorEl.classList.add('collapsed')
				editorEl.ariaLabel = 'Your note'
			})

			listener.updated((ctx, doc) => {
				updated = true

				if (doc.content.size <= 2) {
					empty = true
					if (hasNotes) editorEl.classList.add('collapsed')
					setTimeout(() => {
						rootEl.classList.add('notes-shown')
					}, 50)
					getNotes(opfs).then((notes) => {
						if (notesEl) {
							rootEl.removeChild(notesEl)
						}
						location.reload()
					})
					editorEl.dataset.id = ''
				} else {
					empty = false
					if (hasNotes) rootEl.classList.remove('notes-shown')
					setTimeout(() => {
						editorEl.classList.remove('collapsed')
					}, 50)
				}
			})
		})
		.create()

	let saver = startAutosave()

	const exportButtonEl = document.getElementsByClassName('export')[0]
	notesEl = buildEditor(editor, notes, rootEl, editorEl, true)

	editorEl.focus()
	document.addEventListener('visibilitychange', toggleAutosave)

	document.addEventListener('keydown', (e) => {
		if ((e.ctrlKey || e.metaKey) && e.key === 's') {
			e.preventDefault()
			if (e.repeat) return
			if (e.shiftKey) {
				exportFile(editor, editorEl)
			} else {
				if (!editorEl.dataset?.id) editorEl.dataset.id = nanoid(10)
				save(editor, editorEl, opfs, editorEl.dataset.id, 'shortcut')
			}
		}
		if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
			e.preventDefault()
			if (e.repeat) return
			debug(rootEl)
		}
	})

	editorEl.addEventListener('keydown', (e) => {
		if (e.key === 'ArrowDown' && empty && notesEl) {
			;(
				notesEl.firstElementChild.firstElementChild as HTMLButtonElement
			).focus()
		}
		if (e.key === 'ArrowUp' && empty && notesEl) {
			;(
				notesEl.lastElementChild.firstElementChild as HTMLButtonElement
			).focus()
		}
	})

	initNotesListeners()

	function initNotesListeners() {
		// Probably the worst code I ever wrote
		if (hasNotes)
			[
				...(notesEl.getElementsByClassName(
					'note',
				) as HTMLCollectionOf<HTMLButtonElement>),
			].forEach((noteEl) => {
				noteEl
					.getElementsByClassName('delete')[0]
					.addEventListener('click', (e) => {
						console.debug(`Clicked on ${noteEl.dataset.id}`)
						e.stopPropagation()
						del(noteEl.dataset.id, opfs)
					})
				noteEl.addEventListener('keydown', (e) => {
					const buttonEl = e.target as HTMLButtonElement
					if (e.key === 'ArrowDown' && empty && notesEl) {
						const nextLi = buttonEl.parentElement
							.nextElementSibling as HTMLLIElement
						if (nextLi)
							(
								nextLi.firstElementChild as HTMLButtonElement
							).focus()
						else editorEl.focus()
					}
					if (e.key === 'ArrowUp' && empty && notesEl) {
						const prevLi = buttonEl.parentElement
							.previousElementSibling as HTMLLIElement
						if (prevLi)
							(
								prevLi.firstElementChild as HTMLButtonElement
							).focus()
						else editorEl.focus()
					}
				})
			})
	}

	exportButtonEl.addEventListener('click', () => {
		exportFile(editor, editorEl)
	})

	function toggleAutosave() {
		if (document.hidden) {
			clearInterval(saver)
		} else {
			saver = startAutosave()
		}
	}

	function startAutosave() {
		return setInterval(() => {
			if (updated && !empty) {
				if (!editorEl.dataset?.id) editorEl.dataset.id = nanoid(10)
				save(editor, editorEl, opfs, editorEl.dataset.id)
			}
			updated = false
		}, autosaveInterval)
	}
</script>
