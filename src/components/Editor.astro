---
import '@styles/header.sass'
import '@styles/editor.sass'
import '@styles/notes.sass'
import { Icon } from 'astro-icon/components'
import { modes } from '@utils/cycleModes'
---

<header class="editor-header">
	<div class="left" data-context="notes">
		<form>
			<input type="file" multiple accept=".md,.txt" id="upload" />
		</form>
		<button class="back"><Icon name="back" /></button>
		<button class="add"><Icon name="add" /></button>
	</div>
	<div class="right">
		<div class="state">saved</div>
		<div class="more">
			<button class="show-more"><Icon name="more" /></button>
			<ul class="more-menu">
				<li><button class="export">Export all</button></li>
				{
					Object.entries(modes).map(([name, values]) => (
						<li>
							<span>
								{name.charAt(0).toUpperCase() +
									name.substring(1).toLowerCase()}
							</span>
							<menu class={name}>
								{values.map((value) => (
									<li>
										<button class={value}>
											{name === 'font'
												? `${value.charAt(0).toUpperCase()}${value.substring(1).toLowerCase()}`
												: ''}
										</button>
									</li>
								))}
							</menu>
						</li>
					))
				}
				<li class="credit">byÂ <a href="https://qurle.net">qurle</a></li>
			</ul>
		</div>
	</div>
</header>
<main></main>
<script>
	import { Editor, rootCtx } from '@milkdown/kit/core'
import { clipboard } from '@milkdown/kit/plugin/clipboard'
import { history } from '@milkdown/kit/plugin/history'
import { indent } from '@milkdown/kit/plugin/indent'
import { listener, listenerCtx } from '@milkdown/kit/plugin/listener'
import { upload } from '@milkdown/kit/plugin/upload'
import { commonmark } from '@milkdown/kit/preset/commonmark'
import { automd } from '@milkdown/plugin-automd'
import { replaceAll } from '@milkdown/utils'
import { buildEditor } from '@utils/buildEditor'
import { debug } from '@utils/debug'
import { del } from '@utils/del'
import { exportAll, exportFile } from '@utils/export'
import { focusToEnd } from '@utils/focusToEnd'
import { getNotes } from '@utils/getNotes'
import { showState } from '@utils/showState'
import { writeToFile, type SaveRef } from '@utils/writeToFile'
import { nanoid } from 'nanoid/non-secure'

	// Utilities
	const autosaveInterval = 5_000
	// Elements
	const headerEl = document.getElementsByTagName('header')[0] as HTMLElement
	const headerLeftEl = headerEl.getElementsByClassName(
		'left',
	)[0] as HTMLElement
	const uploadInput = headerLeftEl.getElementsByTagName(
		'input',
	)[0] as HTMLInputElement
	const addEl = headerLeftEl.getElementsByClassName(
		'add',
	)[0] as HTMLButtonElement
	const backEl = headerEl.getElementsByClassName(
		'back',
	)[0] as HTMLButtonElement
	const stateEl = headerEl.getElementsByClassName('state')[0] as HTMLElement
	const showMoreEl = headerEl.getElementsByClassName(
		'show-more',
	)[0] as HTMLButtonElement
	const menuEl = headerEl.getElementsByClassName(
		'more-menu',
	)[0] as HTMLButtonElement
	const exportButtonEl = headerEl.getElementsByClassName('export')[0]
	const fontsEl = Array.from(
		headerEl
			.getElementsByClassName('font')[0]
			.getElementsByTagName('button'),
	)
	const themeEl = Array.from(
		headerEl
			.getElementsByClassName('theme')[0]
			.getElementsByTagName('button'),
	)
	const rootEl = document.getElementsByTagName('main')[0] as HTMLElement
	// Other
	const opfs = await (
		await navigator.storage.getDirectory()
	).getDirectoryHandle('md', { create: true })
	const notes = await getNotes(opfs)

	// Assinged selectors
	let editorEl: HTMLDivElement = null
	let notesEl: HTMLUListElement = null
	// States
	let updated = false
	let empty = true
	let hasNotes = notes?.length > 0
	let lastSave = Date.now()

	const editor = await Editor.make()
		.use(commonmark)
		.use(history)
		.use(clipboard)
		.use(upload)
		.use(indent)
		.use(listener)
		.use(automd)
		.config((ctx) => {
			ctx.set(rootCtx, rootEl)

			const listener = ctx.get(listenerCtx)

			listener.mounted(() => {
				editorEl = (
					document.getElementsByClassName(
						'editor',
					) as HTMLCollectionOf<HTMLDivElement>
				)[0]
				editorEl.spellcheck = false
				if (hasNotes) editorEl.classList.add('collapsed')
				editorEl.ariaLabel = 'Your note'
			})

			listener.updated((ctx, doc) => {
				updated = true
				const isEmpty = doc.content.size <= 2

				showMoreEl.classList.remove('active')

				if (isEmpty) {
					empty = true
					if (hasNotes) editorEl.classList.add('collapsed')
					setTimeout(() => {
						rootEl.classList.add('notes-shown')
					}, 50)
					headerLeftEl.dataset.context = 'notes'
					getNotes(opfs).then((notes) => {
						hasNotes = notes?.length > 0
						if (notesEl) {
							rootEl.removeChild(notesEl)
						}
						notesEl = buildEditor(editor, notes, rootEl, editorEl)
						initNotesListeners()
					})
					document.title = 'type.'
					exportButtonEl.textContent = 'Export all'
				} else {
					empty = false
					if (hasNotes) {
						notesEl.style.visibility = 'hidden'
						rootEl.classList.remove('notes-shown')
						notesEl.style.visibility = 'visible'
					}
					setTimeout(() => {
						editorEl.classList.remove('collapsed')
					}, 50)
					headerLeftEl.dataset.context = 'editor'
					exportButtonEl.textContent = 'Export file'
				}
			})
		})
		.create()

	let saver = startAutosave()

	notesEl = buildEditor(editor, notes, rootEl, editorEl)

	focusToEnd(editorEl)
	document.addEventListener('visibilitychange', toggleAutosave)

	document.addEventListener('keydown', (e) => {
		if ((e.ctrlKey || e.metaKey) && e.key === 's') {
			e.preventDefault()
			if (e.repeat) return
			if (e.shiftKey) {
				exportFile(editor, editorEl, stateEl)
			} else {
				save('shortcut')
			}
		}
		if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
			e.preventDefault()
			if (e.repeat) return
			debug(rootEl)
		}
		if (e.key === 'Escape') {
			save('clear')
			clearEditor()
		}
	})

	editorEl.addEventListener('keydown', (e) => {
		if (e.key === 'ArrowDown' && empty && notesEl) {
			;(
				notesEl.firstElementChild.firstElementChild as HTMLButtonElement
			).focus()
		}
		if (e.key === 'ArrowUp' && empty && notesEl) {
			;(
				notesEl.lastElementChild.firstElementChild as HTMLButtonElement
			).focus()
		}
	})

	backEl.addEventListener('click', () => {
		save('clear')
		clearEditor()
	})

	addEl.addEventListener('click', () => {
		uploadInput.click()
	})

	uploadInput.addEventListener('change', (e: InputEvent) => {
		processFiles(uploadInput.files)
	})

	showMoreEl.addEventListener('click', () => {
		showMoreEl.classList.toggle('active')
	})

	// Hide menu
	document.documentElement.addEventListener('click', (e: MouseEvent) => {
		if (
			!menuEl.contains(e.target as Node) &&
			!showMoreEl.contains(e.target as Node)
		)
			showMoreEl.classList.remove('active')
	})

	exportButtonEl.addEventListener('click', () => {
		if (!empty) exportFile(editor, editorEl, stateEl)
		else exportAll(opfs, stateEl)
	})

	window.addEventListener('beforeunload', () => {
		save('unload')
	})

	initNavigationListener()
	initModeSwitchListeners()
	initNotesListeners()
	initDragAndDrop()

	function initModeSwitchListeners() {
		fontsEl
			.find((el) =>
				el.classList.contains(document.documentElement.dataset.font),
			)
			.classList.add('current')

		themeEl
			.find((el) => {
				return el.classList.contains(
					document.documentElement.dataset.theme,
				)
			})
			.classList.add('current')

		fontsEl.forEach((button) => {
			button.addEventListener('click', () => {
				fontsEl.forEach((el) => el.classList.remove('current'))
				activateMode('font', button.className)
				button.classList.add('current')
			})
		})

		themeEl.forEach((button) => {
			button.addEventListener('click', () => {
				themeEl.forEach((el) => el.classList.remove('current'))
				activateMode('theme', button.className)
				button.classList.add('current')
			})
		})
	}

	function initDragAndDrop() {
		editorEl.addEventListener('dragover', (e) => {
			editorEl.classList.add('dragover')
		})
		editorEl.addEventListener('dragleave', () => {
			editorEl.classList.remove('dragover')
		})
		editorEl.addEventListener('drop', (e) => {
			editorEl.classList.remove('dragover')
			e.preventDefault()
			processFiles(e.dataTransfer.files)
		})
	}

	function initNotesListeners() {
		// Probably the worst code I ever wrote
		if (hasNotes) {
			;[
				...(notesEl.getElementsByClassName(
					'note',
				) as HTMLCollectionOf<HTMLButtonElement>),
			].forEach((noteEl) => {
				noteEl
					.getElementsByClassName('delete')[0]
					.addEventListener('click', (e: MouseEvent) => {
						e.stopPropagation()
						const confirmed = e.shiftKey
						del(noteEl.dataset.id, opfs, confirmed)
					})

				noteEl.addEventListener('keydown', (e) => {
					const buttonEl = e.target as HTMLButtonElement
					if (e.key === 'ArrowDown' && empty && notesEl) {
						const nextLi = buttonEl.parentElement
							.nextElementSibling as HTMLLIElement
						if (nextLi)
							(
								nextLi.firstElementChild as HTMLButtonElement
							).focus()
						else editorEl.focus()
					}
					if (e.key === 'ArrowUp' && empty && notesEl) {
						const prevLi = buttonEl.parentElement
							.previousElementSibling as HTMLLIElement
						if (prevLi)
							(
								prevLi.firstElementChild as HTMLButtonElement
							).focus()
						else editorEl.focus()
					}
				})
			})
		}
	}

	function initNavigationListener() {
		window.addEventListener('popstate', (e) => {
			e.preventDefault()
			console.debug(e)
			if (e.state.page === null) {
				save('clear')
				clearEditor()
				location.reload()
			}
		})
	}

	function save(ref: SaveRef) {
		if (!empty && (ref !== 'autosave' || updated)) {
			console.debug(`Current ID: ${editorEl.dataset?.id}`)
			const id = editorEl.dataset?.id || newId()
			editorEl.dataset.id = id
			writeToFile(editor, editorEl, opfs, id, stateEl, ref)
			updated = false
			return true
		}
		return false
	}

	function newId(length = 10) {
		const id = nanoid(10)
		console.debug(`Generated new ID: ${id}`)
		return id
	}

	function toggleAutosave() {
		if (document.hidden) {
			clearInterval(saver)
		} else {
			saver = startAutosave()
		}
	}

	function startAutosave() {
		return setInterval(() => {
			if (Date.now() - lastSave > 3000) {
				save('autosave')
			}
		}, autosaveInterval)
	}

	function activateMode(scope: 'font' | 'theme', mode: string) {
		document.documentElement.dataset[scope] = mode
		localStorage.setItem(scope, mode)
	}

	async function processFiles(fileList: FileList) {
		console.debug('File(s) uploading')
		const allowedFiles = ['md', 'txt']
		const files = [...fileList].filter((file) =>
			allowedFiles.includes(file.name.split('.').pop()),
		)
		if (files?.length === 0) return
		if (files.length === 1) {
			save('overwrite')
			files[0].text().then((t) => {
				console.debug(`Replacing`)
				// Generating new ID to avoid overwrites
				editorEl.dataset.id = newId()
				editor.action(replaceAll(t))
			})
		} else {
			for (const file of files) {
				if (!empty) {
					save('overwrite')
					clearEditor()
				}
				console.debug(`Writing file ${file.name}`)
				writeToFile(
					editor,
					editorEl,
					opfs,
					newId(),
					stateEl,
					'multiple-drop',
					await file.text(),
				)
				location.reload()
			}
			showState(stateEl, `uploaded ${files.length} files`)
		}
	}

	function clearEditor() {
		editor.action(replaceAll(''))
		empty = true
		window.history.pushState({ page: null }, '', '')
		editorEl.dataset.id = ''
	}
</script>
